import { db } from '@/lib/firebase';
import { 
  collection, 
  addDoc, 
  getDocs, 
  doc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy,
  Timestamp 
} from 'firebase/firestore';
import { DraftTransaction } from '@/types';

const COLLECTION_NAME = 'draftTransactions';

export const addDraftTransaction = async (draftTransaction: Omit<DraftTransaction, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> => {
  try {
    const now = new Date().toISOString();
    const docRef = await addDoc(collection(db, COLLECTION_NAME), {
      ...draftTransaction,
      createdAt: now,
      updatedAt: now,
    });
    return docRef.id;
  } catch (error) {
    console.error('Error adding draft transaction:', error);
    throw error;
  }
};

export const getDraftTransactions = async (userId: string): Promise<DraftTransaction[]> => {
  try {
    const q = query(
      collection(db, COLLECTION_NAME),
      where('userId', '==', userId)
    );
    
    const querySnapshot = await getDocs(q);
    const draftTransactions: DraftTransaction[] = [];
    
    querySnapshot.forEach((doc) => {
      draftTransactions.push({
        id: doc.id,
        ...doc.data()
      } as DraftTransaction);
    });
    
    // Sort by createdAt on the client side to avoid index requirements
    return draftTransactions.sort((a, b) => {
      const dateA = new Date(a.createdAt).getTime();
      const dateB = new Date(b.createdAt).getTime();
      return dateB - dateA; // Newest first
    });
  } catch (error) {
    console.error('Error getting draft transactions:', error);
    throw error;
  }
};

export const getPendingDraftTransactions = async (userId: string): Promise<DraftTransaction[]> => {
  try {
    const q = query(
      collection(db, COLLECTION_NAME),
      where('userId', '==', userId),
      where('status', '==', 'pending')
    );
    
    const querySnapshot = await getDocs(q);
    const draftTransactions: DraftTransaction[] = [];
    
    querySnapshot.forEach((doc) => {
      draftTransactions.push({
        id: doc.id,
        ...doc.data()
      } as DraftTransaction);
    });
    
    // Sort by createdAt on the client side to avoid index requirements
    return draftTransactions.sort((a, b) => {
      const dateA = new Date(a.createdAt).getTime();
      const dateB = new Date(b.createdAt).getTime();
      return dateB - dateA; // Newest first
    });
  } catch (error) {
    console.error('Error getting pending draft transactions:', error);
    throw error;
  }
};

export const updateDraftTransaction = async (id: string, updates: Partial<DraftTransaction>): Promise<void> => {
  try {
    const draftRef = doc(db, COLLECTION_NAME, id);
    await updateDoc(draftRef, {
      ...updates,
      updatedAt: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Error updating draft transaction:', error);
    throw error;
  }
};

export const approveDraftTransaction = async (id: string): Promise<void> => {
  try {
    await updateDraftTransaction(id, { 
      status: 'approved',
      updatedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error approving draft transaction:', error);
    throw error;
  }
};

export const rejectDraftTransaction = async (id: string): Promise<void> => {
  try {
    await updateDraftTransaction(id, { 
      status: 'rejected',
      updatedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Error rejecting draft transaction:', error);
    throw error;
  }
};

export const deleteDraftTransaction = async (id: string): Promise<void> => {
  try {
    await deleteDoc(doc(db, COLLECTION_NAME, id));
  } catch (error) {
    console.error('Error deleting draft transaction:', error);
    throw error;
  }
};

export const createDraftFromRecurringTransaction = async (
  userId: string, 
  sourceTransaction: any, 
  dueDate: string
): Promise<string> => {
  try {
    const draftTransaction: Omit<DraftTransaction, 'id' | 'createdAt' | 'updatedAt'> = {
      userId,
      name: sourceTransaction.name,
      categoryId: sourceTransaction.categoryId,
      date: dueDate,
      amount: sourceTransaction.amount,
      type: sourceTransaction.type,
      accountId: sourceTransaction.accountId,
      status: 'pending',
      sourceTransactionId: sourceTransaction.id,
      sourceType: 'recurring',
      notes: `Auto-generated from recurring transaction: ${sourceTransaction.name}`,
      autoGenerated: true,
    };

    return await addDraftTransaction(draftTransaction);
  } catch (error) {
    console.error('Error creating draft from recurring transaction:', error);
    throw error;
  }
};

export const createDraftFromLoanInstallment = async (
  userId: string,
  loanId: string,
  installment: any,
  accountId: string
): Promise<string> => {
  try {
    const draftTransaction: Omit<DraftTransaction, 'id' | 'createdAt' | 'updatedAt'> = {
      userId,
      name: `Loan Payment - Installment ${installment.installmentNumber}`,
      categoryId: '', // Will need to be set based on loan category
      date: installment.dueDate,
      amount: installment.amount,
      type: 'expense',
      accountId,
      status: 'pending',
      sourceTransactionId: loanId,
      sourceType: 'loan_installment',
      notes: `Auto-generated from loan installment #${installment.installmentNumber}`,
      autoGenerated: true,
    };

    return await addDraftTransaction(draftTransaction);
  } catch (error) {
    console.error('Error creating draft from loan installment:', error);
    throw error;
  }
};
